**********************************************************************************************************

API

What is Content Negotiation?
It is one of the standard for Restful services.
It is the process of selecting the best response from the available set of responses. i.e for client1 we can return JSON
and for client2 we can return XML for the same API call.

By default JSON is the return format

There are 2 main headers which are responsible for Content Negotiation
	1. Accept - They specify the format in which Client will accept the response.
	 accept : application/xml	//To accept as XML
	 accept : application/json	//To accept as JSON

	 We can mention multiple accept header value
	 accept : application/xml, application/json //Here we will get XML as XML is mentioned first

	 We can also mention the quality factor within accept.
	 accept : application/xml;q=0.5, application/json;q=0.6 
	 //Here the format which has higher quality will be given preference
	 //json has higher quality so json will be returned


	2. Content-Type - Using content-type header, the client can specify the format of an object going to post on the server
	in case method is POST,PUT,PATCH
	

	Summary - 
	Content-type -> Format sent from Client to Server
	Accept -> Formet sent from Server to Client to accept

****************************************************************************************************

What is life cycle of API
	
The lifecycle of a WebAPI (Web Application Programming Interface) refers to the various stages and steps that a web API request 
goes through from the moment it is initiated by a client until the response is received. 


	1. Routing and URL Matching & Controller Selection 

	The client sends an HTTP request to a specific URL representing an endpoint of the WebAPI.
	The web server receives the request and forwards it to the appropriate routing mechanism in the WebAPI framework.
	
	The routing mechanism identifies the appropriate controller and action method based 
	on the URL and HTTP verb (GET, POST, PUT, DELETE, etc.).
	The selected controller and action method will handle the incoming request.

	2. Model Binding and Parameter Extraction:

	The framework extracts data from the request, such as query parameters, route parameters, 
	headers, and request body data. 
	This data is then used to populate the parameters of the selected action method.

	3. Action Method Execution:

	The selected action method is invoked, and it performs the required processing based on the received data.
	The action method typically returns an instance of IHttpActionResult or a specific response type.

	4. Content Negotiation and Response Formatting:

	The response generated by the action method is passed through a content negotiation process.
	The content negotiation process determines the best representation of the response based on the 
	client's Accept header and available response formatters (XML, JSON, etc.).
	The response is formatted into the chosen representation.

	5. Response Generation and Sending With Exception handling:

	The formatted response is sent back to the client as an HTTP response.
	The appropriate status code, headers, and response body are included in the HTTP response.
	If an exception occurs during any of the previous stages, the framework handles it by invoking exception filters and error handling mechanisms.
	An error response is generated and sent back to the client with relevant error information.

	6. Response Transmission:

	The final HTTP response is transmitted over the network to the client.

************************************************************************************************

What is model binding?

Model binding in WebAPI is a process that automatically maps and populates the parameters of a controller action method 
with data from the incoming HTTP request. 

There are several types of model binding in WebAPI:

1. Simple Type Binding:

	Simple types like integers, strings, booleans, and enums are automatically bound from query parameters, route values, and request headers.
	For example, if an action method has a parameter named id, WebAPI will attempt to bind it from the route values or query parameters.

2. Complex Type Binding:

	Complex types, such as custom classes or models, are bound from the request body (usually in JSON or XML format) or from other data sources.
	The properties of the complex type are populated based on the corresponding data in the request.

3. Parameter Binding Sources:

	Model binding can retrieve data from various sources, including query parameters, route values, request headers, and the request body.
	Developers can specify the binding source explicitly using attributes like [FromQuery], [FromRoute], [FromHeader], and [FromBody].


What is parameter binding?

Parameter binding in WebAPI refers to the process of automatically mapping and populating the parameters 
of a controller action method with data from the incoming HTTP request. 
It's a crucial part of how WebAPI handles incoming requests and allows developers to work with the data directly in 
their action methods without having to manually extract and parse the data from the request.

WebAPI's parameter binding works by examining the incoming request and matching the parameters 
of the action method with the data in the request. 
The data can come from various sources, including query parameters, route values, request headers, 
and the request body, depending on the specific attribute used to annotate the parameter.

Here are some common parameter binding attributes in WebAPI:

FromQuery:

	The [FromQuery] attribute is used to bind data from query parameters in the URL.
	
	Example: public IHttpActionResult GetUsers([FromQuery] string searchTerm)

FromRoute:

	The [FromRoute] attribute is used to bind data from route values in the URL.

	Example: public IHttpActionResult GetUserById([FromRoute] int id)

//FromHeader: 
//
//	The [FromHeader] attribute is used to bind data from HTTP headers in the request.
//
//	Example: public IHttpActionResult UpdateUser([FromHeader] string authorizationToken)

FromBody:

	The [FromBody] attribute is used to bind data from the request body. It's often used for complex types like custom models.
	Example: public IHttpActionResult CreateUser([FromBody] UserModel user)

//FromUri (Obsolete):
//
//	The [FromUri] attribute was used in older versions of WebAPI to explicitly indicate binding from the URI (including query parameters). 
//	It's now less commonly used because WebAPI performs this kind of binding automatically.


	public class UserController : ApiController
	{
		// GET api/users?searchTerm=10
		public IHttpActionResult GetUsers([FromQuery] string searchTerm)
		{
			// 'searchTerm' will be automatically bound from the query parameter.
			// Use 'searchTerm' to filter and return users.
		}

		// GET api/users/{id}
		public IHttpActionResult GetUserById([FromRoute] int id)
		{
			// 'id' will be automatically bound from the route value.
			// Retrieve user information by 'id'.
		}

		// POST api/users
		public IHttpActionResult CreateUser([FromBody] UserModel user)
		{
			// 'user' will be automatically bound from the request body (JSON or XML).
			// Create a new user based on the provided data.
		}
	}

*********************************************************************************************************************************

Revisit this topic for additional questions

What is Rest API?

Rest API Architecture
It is an architectural design that outlines guidelines for developing Web Services. 
In a client-server connection, REST recommends creating an object of the data requested by the client and sending 
the object's values back to the user.


How does the Rest API work?
REST APIs employ HTTP requests to communicate to do routine tasks like creating, reading, updating, and deleting 

entries (also known as CRUD) within a resource. 

-------------------------------------------------------------------------

Features of Rest API

	Scalability: Development teams may quickly scale the solution due to the separation of client and server. 

	Flexibility & Portability: Data from one of the queries must be accurate for REST-style APIs; thus, it is conceivable to transition from one server to another. 
	It is also possible to alter the database at any moment.  

	Independence: Through the isolation of the client and server, the protocol allows for autonomous development across a project.
	REST APIs are also adaptive to the working syntax and platform, enabling you to test many environments simultaneously while building.    

-------------------------------------------------------------------------

Principles or Characteristics of WebApi (Rest)

	REST (Representational State Transfer) architecture is an architectural style for designing networked applications. 
	It provides a set of guidelines and constraints that aim to create scalable, stateless, and well-structured web services. 
	A RESTful API adheres to these principles to enable efficient communication between clients and servers. 
	
	Here are the key architectural principles of a RESTful API:

	1. Client-Server Separation:

	The client and server are separate entities with distinct responsibilities.
	Clients are responsible for user interface, presentation, and user interactions.
	Servers are responsible for managing and exposing resources and handling business logic.

	2. Statelessness:

	Each request from the client to the server must contain all the information needed for the server to understand and process the request.
	The server doesn't store any client context between requests, making it easier to scale and distribute.
	
	3. Cacheability:

	Responses from the server can be marked as cacheable or non-cacheable using HTTP caching mechanisms.
	Caching improves performance by reducing the need for repeated requests for the same data.

	4. Uniform Interface:

	The interface between clients and servers is standardized and consistent.
	Resources are identified using URIs (Uniform Resource Identifiers) and manipulated using standard HTTP methods (GET, POST, PUT, DELETE).
	Use of standard media types (JSON, XML, HTML) enables clients and servers to understand the data format.

	5. Layered System:

	A layered architecture allows intermediaries (proxies, gateways, etc.) to be placed between the client and the server without affecting the overall functionality.
	This enables scalability, load balancing, and security improvements.

	6. HATEOAS (Hypermedia as the Engine of Application State):

	HATEOAS is a constraint that encourages the inclusion of hyperlinks in API responses to guide clients through available actions and resources.
	Clients can navigate the API by following hyperlinks, promoting discoverability.
	When designing a RESTful API, keep these principles in mind to ensure that your API is well-structured, maintainable, and aligns with the core concepts of REST. 
	
	By following these principles, you can create APIs that are easy to understand, scalable, and adaptable to changes over time.

---------------------------------------------------------------------

SOAP vs RESTFul

	SOAP (Simple Object Access Protocol) and RESTful (Representational State Transfer) are two different approaches to designing web services. 
	They have different architectural styles, communication protocols, and characteristics. Here are some key differences between SOAP and RESTful web services:

	1. Protocol vs. Architectural Style:

		SOAP is a protocol that defines a set of rules for structuring messages and allows communication between applications over a network. 
		It often uses XML as the message format.
	
		RESTful is an architectural style that provides a set of guidelines and constraints for building web services. 
		It is not tied to any specific protocol but is often implemented using HTTP.
	
	Message Format:

		SOAP messages are typically formatted in XML and follow a specific structure defined by the SOAP specification. 
		The structure includes a header and a body, where the body contains the actual data.
	
		RESTful services often use a variety of data formats, such as JSON, XML, HTML, and plain text. 
		JSON is widely used due to its lightweight and human-readable nature.
	
	Communication Style:

		SOAP enforces a more rigid and standardized communication style, often using remote procedure call (RPC) patterns. 
		It supports both request-response and one-way communication.
	
		RESTful services use the principles of the HTTP methods (GET, POST, PUT, DELETE) to perform actions on resources. 
		REST is more focused on the manipulation of resources and their representations.
	
	Statelessness:

		SOAP services can be either stateful or stateless, but the SOAP protocol itself does not enforce statelessness.
		
		RESTful services are designed to be stateless, meaning that each request from the client contains all the necessary information for the server to understand and process it.
	
	Flexibility:

		SOAP is more rigid and requires adherence to a strict set of rules defined by the protocol. It provides more built-in security features, like WS-Security.
		
		RESTful services are more flexible and adaptable, allowing developers to choose how they structure their resources and how they handle security.
	
	HATEOAS:

		HATEOAS (Hypermedia as the Engine of Application State) is a constraint of REST that enables clients to navigate the API by following hyperlinks provided in the responses.
		
		SOAP does not inherently provide a standard for HATEOAS, though it's possible to implement it.
	
	Performance:

		SOAP messages can be larger due to the XML format and additional headers, potentially impacting performance.
		
		RESTful services, especially when using JSON, tend to be more lightweight and require less bandwidth.
	
	Usage Scenarios:

		SOAP is often used in enterprise scenarios where security, reliability, and formal contracts are crucial, such as in financial or healthcare applications.
		
		RESTful services are well-suited for public APIs, web applications, mobile apps, and scenarios where simplicity, scalability, and ease of use are important.
		
		Ultimately, the choice between SOAP and RESTful depends on the specific requirements of your project, the desired communication style, the level of formality needed, and the platforms and technologies you're working with.


-------------------------------------------------------------------------------------------------

API Verbs

API verbs, also known as HTTP methods, are the actions that can be performed on resources when interacting with a RESTful API. 
These verbs define the type of operation to be performed on a resource, such as retrieving data, creating new records, updating existing records, or deleting records. 
HTTP methods play a crucial role in implementing the CRUD (Create, Read, Update, Delete) operations in a RESTful API. 
Here are the commonly used HTTP methods and their corresponding actions:

	GET:

	The GET method is used to retrieve data from the server.
	It is safe, meaning it does not modify data on the server.
	Used to retrieve representations of resources.
	
	POST:

	The POST method is used to submit data to be processed by the server.
	It is used for creating new resources or performing actions that modify data on the server.
	Submits data to be processed to a specified resource.

	PUT:

	The PUT method is used to update data on the server.
	It replaces the entire representation of a resource with the submitted data.
	Used to update or create a resource with a specific identifier.

	PATCH: 

	The PATCH method is used to partially update data on the server.
	It applies partial modifications to a resource without replacing the entire representation.
	Useful when you only want to update specific fields.

	DELETE:

	The DELETE method is used to remove a resource from the server.
	It deletes the specified resource, if it exists.
	Used to delete a resource identified by a specific identifier.
	
	OPTIONS:

	The OPTIONS method is used to request information about the communication options available for a resource.
	It can be used to determine which HTTP methods are supported by a resource, among other details.
	
	HEAD:

	The HEAD method is similar to GET but only returns headers and no actual response body.
	It's often used to check resource availability, content length, or last-modified date without downloading the full content.
	These HTTP methods provide a standardized way to interact with resources in a RESTful API. The choice of which method to use depends on the type of action you want to perform on the resource. When designing your API, it's important to use the appropriate HTTP method for each type of operation to ensure that your API follows REST principles and is intuitive for developers to use.

----------------------------------------------------------------------------------------------------------------------------------------

Routing

https://www.c-sharpcorner.com/article/convention-routing-vs-attribute-routing/
https://thecodeblogger.com/2021/05/29/conventional-vs-attribute-routing-in-asp-net-core-apps/

Check - Basic routing, Areas, Attribute Routing, Verb Routing

---------------------------------------------------------------------------------------------------------------------------------
//Ignore
Long Running Process

Handling long-running processes in a .NET API involves managing the execution of time-consuming tasks without blocking 
the responsiveness of your application. There are several approaches you can take to achieve this, depending on 
your requirements. Here's a general outline of steps you can follow:

1. Asynchronous Programming: Utilize asynchronous programming to avoid blocking the main thread of your application 
while the long-running process is executing.

2. Background Services: Use a background service or worker to handle long-running tasks independently of the main 
request-response cycle. This can be achieved using tools like BackgroundService or IHostedService in ASP.NET Core.

3. Task Queues: Implement a task queue system to manage and prioritize long-running tasks. Azure services like Azure 
Queue Storage or Azure Service Bus can be used for this purpose.

4. Parallel Processing: If the long-running process can be divided into smaller chunks, consider using parallel 
processing to utilize multiple CPU cores effectively.

5. Cancellation and Progress Reporting: Implement mechanisms to allow users to cancel or monitor the progress of 
long-running tasks.

6. Timeouts and Error Handling: Set appropriate timeouts and implement error handling to gracefully manage scenarios 
where a long-running process takes longer than expected or encounters errors.

NOTE - For a long running we can return status as 102 - Processing

---------------------------------------------------------------------------------------------------------------------------------

What is the advantage of RestApi

---------------------------------------------------------------------------------------------------------------------------------

Custom Response for WebApi

	public class ApiResponseModel<T>
    {
        public T Data { get; set; }
        public ApiError Error { get; set; }
    }

    public class ApiError
    {
        public string ErrorCode { get; set; }
        public string ErrorMessage { get; set; }
    }


How to manipulate timeout so that a lengthy operation can happen.
Request Validations
How to write logs to trace requests from WebApi from multiple sources.


1. NgDoCheck vs NgOnchange
2. Use of Spread Operator
3. Implement lazy loading in angular
4. Lazy loading in .net
5. Observable vs Promise
6. Popular MVC questions



1. Ans -> 
ngDoCheck - It will be called for every change detection.
ngOnChange - It will be called when data bound input property change. 
	That is when there is a parent child communication using the input().
































