This project has basic .net core C# examples

Terms - 

------------------------------------------------------------------------------------------------------

Boxing and Unboxing - 

Boxing - The process of Converting a Value Type (char, int etc.) to a Reference Type(object) is called Boxing.
Boxing is implicit conversion process in which object type (super type) is used.
The Value type is always stored in Stack. The Referenced Type is stored in Heap.
Example :
int num = 23; // 23 will assigned to num
Object Obj = num; // Boxing

Unboxing - The process of converting reference type into the value type is known as Unboxing.
It is explicit conversion process.
Example :
int num = 23;         // value type is int and assigned value 23
Object Obj = num;    // Boxing
int i = (int)Obj;    // Unboxing

------------------------------------------------------------------------------------------------------

CLR and CLI - 
(Already open in the last tab. To be Updated)
------------------------------------------------------------------------------------------------------

Reflection - It is inspection of an Assembly and checking what are the usable members the assembly contains.

------------------------------------------------------------------------------------------------------
Var vs Dynamic

 * Var - It is early binded. So when value is assigned compiler will be able to detect the metadata like what kind of value it contains.
 * Dynamic - It is late binded. It is binded during runtime. So what value has been assigned would not be evaluated by compiler.
 Even if some error will be assigned to it say 
 dynamic a = "ABC";
 int t = a.length //It must be a.Length (Caps L)
 this would not be any error during compile time but during run-time there would be exceptions.
 
 ------------------------------------------------------------------------------------------------------

 C# value type vs reference type

 Value type - A data type which holds a data value within its own memory space. That is they directly contains value. 
 So when used with functions whenever we pass the value in the parameter, the parameter will create its own memory space.
 Ex - All basic/primitive data types (except string) + Struct + enum

 Reference type - A reference type does not hold the value directly rather it will hold the value of the address 
 where its actually value is actually stored. 
 The default value of a reference type variable is "null" when they are not initialized. Null means not refering to any object.
 When used with function no new copy is created instead address is passed.
 Ex - String, stringbuilder, array (even its elements are value type), class, delegate


 ------------------------------------------------------------------------------------------------------

 Delegate - Its a type safe pointer to a function. It should match with the signature of the method.

 Note - In C# a class is a reference type and a struct is a value type. And all the references should be defined under Namespace. 
 So delegate must be defined under Namespace.

 But the question here is if a method can be called directly then why do we need to call the method indirectly.

 The meaning of delegate is a representative to communicate between parties.
 Purpose - So we will primarily use it for callbacks. That is when another method is called and we need to gather some info from 
 that another method we can use delegates for live data from that method. Typically used in parallel processing.
 It can be used to decouple method logic.

 Multicast Delegate - When a delegate is used for reference to more than one method it is called multicast delegate.

 Delegate can be used in shorter versions
 1. Lambda expression for the above code - It is more shorter version of delegate
 2. Func <with input as double, output as double> - It will take an input and produce and output (it might not have any input)
 3. Action - This will take an input and do some work (and may or may not return any output) 
 4. Predicate - This will take an input and will return and output as boolean

 ------------------------------------------------------------------------------------------------------

 Stacks and Heaps	

 1) Primitive data type will be stored in Stacks 
 and Reference types like objects are stored in Heaps

 2) Now for objects say 
 Object obj1 = new Object();
 obj1.Name = "ABC;
 Here obj1 reference are stored in stack and the values i.e obj1.Name is stored in heap.
 
 In stack data has to be pushed/removed from top only 
 but in heap data can be pushed or removed in any order.

 In stack recursion calls fills it up quickly 
 for heap recursion calls fills it uo slowly

 Stack - We get stackOverflow when memory is exhausted, local variables get wiped off once they loose scope.
 Heap - GC - It is a special thread created by .NET runtime to monitor allocations of heap space.
 It only collects heap memory since objects are only created in heap

------------------------------------------------------------------------------------------------------

 Garbage Collector - It is a background process which runs in the background and cleans unreferenced managed objects from memory.
	It will clean objects once objects are out of scope.
	Garbage collector does not work on premitive types as it does not work on Stack. (These primitive types will be automatically
	cleaned once they go out of scope).


	 Managed resources are those which are pure .net objects and these objects are controlled by .net CLR. They are cleaned by GC.
	 Unmanaged resources are those which are not managed by .net CLR like Files,Conn objects (for DB) etc. They are not cleaned by GC.

	 Note - Total Memory of .net application = Managed Memory + Unmaneged Memory

	 GC generations - They are logical buckets and each bucket defines how old the objects are. They are GC0, GC1, and GC2
	 So,
	 GC0 - It contains short lived objects.
	 GC1 - It contains intermediate lived objects.
	 GC2 - It contains long lived objects.
	 Purpose - Having generations have good performance effect. So objects in GC0 will be visited by GC more than the objects in GC2.


	Note - Managed code will be cleaned by GC. And for unmanaged code () we need to explicitly clean them by using Destructors or related processes.

	"Destructor" -> ~Constructor() Name -
	Here we put the unmanaged code to be cleaned. The Destructor is called implicitly by the .NET Framework’s Garbage collector 
	and therefore programmer has no control as when to invoke the destructor. An instance variable or an object is eligible for 
	destruction when it is no longer reachable.

	1. When we have Destructor in our code the GC has to work more and will have to do more trips to clean.
	2. A Destructor has no return type and has exactly the same name as the class name (Including the same case).
	3. A Destructor does not accept any parameters and modifiers.

	So if we have a destructor then GC will give priority to cleaning based upon the destructor first, then it will clean rest of the 
	references not specified in destructor.

	So, having an empty destructor is bad as it may push unused references of GC0 in destructor to GC1 and so on.

	"Finalize" - It is same as destructor internally Destructor calls Finalize.

	Q. Explain Dispose pattern?

	When we have an empty destructor then we use IDisposable interface. (This fixes the issue of empty destructor)

	public class SomeClass : IDisposable{

		~SomeClass(){
		}

		public void Dispose(){
			//Code to clean
			GC.SuppressFinalize(this);
		}

	}

	public class CallingClass{

		public void MyFunct1(){
			SomeClass obj = new SomeClass();
			//Some work
			obj.Dispose();	//Calling dispose of the class
		}

	}

	This will tell the flow not to call the destructor and the unmanaged code will be handled. With this message GC will claim the unreferenced
	managed objects as without waiting for the Destructor.

	******************************************
	Here we have an important Concept - Why do use using statement for using unmanaged code such as network connections?

	Because implementing "using()" will define a scope, once the flow goes outside this scope then objects will be disposed automatically.

	So we modify the code above

		public void MyFunct1(){

			using(SomeClass obj = new SomeClass())
			{
				//obj.Dispose();	//Automatically calling dispose of the class
			}
		}


	******************************************

	Q. Can we force Garbage Collector to run?
	Yes by calling GC.Collect();

	Note - GC.Collect() can be placed anywhere in the code as required but it is a good practice if we have a Dispose() method '
	then call GC.Collect() after the Dispose();

	Also GC.Collect() - Simple call
	GC.Collect(0) - Call gen 0 
	GC.Collect(1) - Call gen 1
	GC.Collect(2) - Call gen 2

	Note - It is recommended not to explicitly call GC.Collect() if not needed. As it will be smartly called.

	Q. How can we detect a bad memory and its source of issue?

	Ans - We will use performance profiler.
	We will check how .net objects are allocated.
	We need to check which portion of the code has huge memory allocation and then class needs to be refactored.

	Q. What is memory leak?
	Its a situation where memory used by the application is not returned to the OS even when the application exits.

	Concept - Total Memory of .net application = Managed Code + Unmanaged Code
		We also have primitive variables but they will be released from Stack once they are out of scope

	Q. Can a .net application have memory leak as we already have a Garbage Collector?
	We can still have memory leaks for unmanaged codes as GC does not work explicitly on unmanaged code.

	Q. Explain Strong references vs Weak references?
	Concept - Object created -> Object Not needed -> After some time GC runs. So there is some Delta before the GC actually collects.

	"Strong reference" - It is a normal object. i.e once its reference is not needed it will be claimed by GC. 
	Here even if there is some time (Delta) before the next GC run the object is not accessible during this delta.

	"Weak reference" - It is a object which permits the garbage collector to collect itself while still 
	allowing the application to access the object till the next GC run (during this delta). So here the object marks itself for 
	GC collect but will be available during the delta before the actual GC run.

	Ex - 

	public class MyClass{
	
		static WeakReference weak = new WeakReference(null);

		public void Func1()
		{
			var obj = new SomeClass();

			weak.Target = obj; 
			//weak.IsAlive	//If the obj is alive then we will access it.
		}
	}


	Ex - 

	class Program
	{
		static WeakReference weakRef = new WeakReference(null);

		static void Main(string[] args){

			Func1(); //SomeClass is called
	
			while(1==1){
				SomeClass gc = new SomeClass(); //SomeClass is called again - Provoking GC when the reference ends
				Console.WriteLine(weakRef.IsAlive);	//Checking if still this object is available
			}
		}

		static void Func1(){
			SomeClass t = new SomeClass();
			weakRef.Target = t;
		}


	}

	Q. When we will use weak reference?
	Ans - Caching, object pooling. Wherever object creation is resource intensive caching and pooling can improve performance.


------------------------------------------------------------------------------------------------------

App Domain

Asp.Net introduces the concept of an Application Domain which is shortly known as AppDomain. 
It can be considered as a Lightweight process which is both a container and boundary. The .NET runtime uses an AppDomain 
as a container for code and data, just like the operating system uses a process as a container for code and data. 
As the operating system uses a process to isolate misbehaving code, the .NET runtime uses an AppDomain to isolate code 
inside of a secure boundary.

The CLR can allow the multiple .Net applications to be run in a single AppDomain.

The CLR isolates each application domain from all other application domains and prevents the configuration, security, 
or stability of a running .NET applications from affecting other applications.An AppDomain can be destroyed without 
effecting the other Appdomains in the process.

Ref : https://www.youtube.com/watch?v=DUq84e3cZyo

------------------------------------------------------------------------------------------------------

Yield (Keyword) - https://www.youtube.com/watch?v=4fju3xcm21M&t=2s

------------------------------------------------------------------------------------------------------

String comparison
Best way = 

Val.Equals("SqlServer", StringComparison.OrdinalIgnoreCase);



Object comparison
val1 == val2 -> Checks if references are same
val1.Equals(val2) -> Checks if contents are same

Note - For string it will be content comparision

------------------------------------------------------------------------------------------------------

Aggregation vs Composition vs Association

	Interitance - IS A (relation) parent - child relation
	Using - HAS A (relation)

	What are the different types of USING / HAS A relation?
	Ans - Aggregation, Composition, Association

	Concept - Part-Whole relation - Ex - Wheel is a part of the whole car.
	For Composition and Aggregation has Part-Whole relationship

	Ex - 

	class Patient
	{
		public List<Problem> problems {get; set;}
		public Doctor Doctor {get; set;}
		
		public Patient(){
			Checkbed checkbed = new Checkbed();
			int bedNo = checkbed.Getbedno();

			Doctor doc = new Doctor();
			problems = new List<Problem>();
		}
	}

	Class Doctor{
		public Doctor(){
		
		}
	}

	Class Checkbed{
		public Checkbed(){
		
		}
	
		Getbedno(){
		
		}
	}


	Here class Patient is whole 
	and problems is a part of it.

	Please note on the vocabularies

	1. Composition Relation - Composition is a part-whole relationship where both part and whole object
	have same life time. One cannot stay without each other. Its like a death relationship. 

	That is the internal members of the class must have the same lifetime as of the class.

	In the above code Patient and Problems have similar lifetime. That is till the person is patient it is due to the problems.
	So Patient-person HAS A composition (1:1 relation). They are tightly coupled as the members are of the same class.

	2. Aggregation Relation - Aggregation is a part-whole relationship where both part and whole object 
	have different life time. They can have different life time.

	In the above code Patient and Doctors can have different lifetime. That is multiple doctors can have multiple patients.
	So Patient-doctor HAS A aggregation (M:N relation). There is no exclusive ownership. 
	Here no tightly coupled as Members are of different class.

	3. Association - It is a superset of composition and aggregation. It defines how two objects are dependent on each other.

	In the UML we can use 
	Composition -> Filled diamond
	Aggregation -> Empty diamond
	Association -> Arrow

------------------------------------------------------------------------------------------------------

IEnumerable vs IQueryable

Typically used for data fetching. If we have data fetched with filters then IEnumerable will simply fetch all the data and apply filter
from application. And IQueryable will first apply filter on the data at DB then pull the data to application.

IEnumerable 
1. It exists in System.Collections Namespace.
2. IEnumerable is best for querying data from in-memory collections like List, Array, etc.
3. IEnumerable is suitable for LINQ to Object and LINQ to XML queries.
4. IEnumerable doesn't support lazy loading. Hence not suitable for paging like scenarios.

IQueryable 
1. It exists in System. Linq Namespace.
2. IQueryable is best for querying data from out-memory (like remote Database, service) collections.
3. IQueryable is suitable for LINQ to SQL queries.
4. IQueryable support lazy loading. Hence it is suitable for paging like scenarios.

------------------------------------------------------------------------------------------------------

C# Copying objects -

Shallow Copy

	A Shallow Copy is about copying an object's value type fields into the target object and the object's reference types 
	are copied as references into the target object but not the referenced object itself. 
	It copies the types bit by bit. The result is that both instances are cloned and the original will refer to the same object.

	Class1 obj1 = new Class1();
	Class1 obj2 = obj1;

Deep Copy (New Copy with new references)

	Deep Copy is used to make a complete deep copy of the internal reference types, for this we need to configure the object 
	returned by MemberwiseClone().

	Class1 : IClonable
	{
		public object Clone(){
			Class1 obj = (Class1)this.MemberwiseClone();
		}
	}

	Class1 obj1 = new Class1();
	Class1 obj2 = (Class1)obj1.Clone();

------------------------------------------------------------------------------------------------------

Sealed classes are used to restrict the users from inheriting the class. 
A class can be sealed by using the sealed keyword. The keyword tells the compiler that the class is sealed, 
and therefore, cannot be extended. No class can be derived from a sealed class.

A method can also be sealed, and in that case, the method cannot be overridden. 
However, a method can be sealed in the classes in which they have been inherited. If you want to declare a method as sealed, 
then it has to be declared as virtual in its base class.


------------------------------------------------------------------------------------------------------

Serialize - Object to JSON/XML or Stream
Deserialize - JSON/XML/Stram to object

------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------


Can we call static from non static methods? Yes we can

Object copy

array clean

array to list

extension method


