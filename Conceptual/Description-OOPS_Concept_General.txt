OOPS - Object-Oriented Programming System

    Features
        1. Emphasis on Data rather than procedure.
        2. Data security
        3. Follows bottom-up approach. 
	    Here in this approach the modules are designed individually and are then integrated together to complete the design.
	    Advantage - Testing and Reusability gets easier.
	    While the top-down approach focusses on breaking down a bigger problem into smaller and understandable chunk, the 
	    bottom-up approach first focusses on solving the smaller problems at the fundamental level and then integrating them 
	    into whole and complete solution.

    Properties
        1.	Classes and Objects.
        2.	Data abstraction and encapsulation - Wrapping up of data and functions into a single unit (called class) is known 
	        as "encapsulation". The data is generally not accessible to outside world and methods inside the class can access it.
	        So the methods form the medium through which data can be exchanged between object and the program. This insulation from
	        direct access by the program is called "data hiding".
	        Abstraction referes to the act of representing essential features without including the background details or explanations.
	        Since classes use the concept of data abstraction they are known as Abstract Data types.
        3.	Inheritance - It is the process by which one class acquire the properties of objects of another class.
        4.  Polymorphism - Same name but different logic. Ex - Method overloading : Here we can have multiple methods of same name 
	        but different parameters. Ex - Operator Overloading : Operator exhibit different behavior in diff instances.
        5.	Dynamic Binding - Also called late binding. Here the code associated with a given procedure call is not known till the 
	        code is run or at instantiation.

************************************************************************

Data Types
1. Built-in Types - Integral Types - Int, Char
					Void
					Floating - Float, double
2. User-Defined - Structure, Union, Class, enum
3. Derived - Array, function, pointer, reference

************************************************************************

C++ Example of Pointers - 
	int *ptr;
	ptr = &add; //Assign address of "add" in ptr
	*ptr = 10; //10 is assigned to "add" through indirection

C++ SizeOf Operator Example - 
	sizeof('x'); or sizeof(int);


//PascalCase vs camelCase

************************************************************************

Reference Variable - Its an alias to the original variable. The reference variable and the original variable will share the same memory space.
	Ex :	float total = 100;
			float &sum = total;

Type cast in C# 
	Ex int a = (int) 1.01;

************************************************************************
(IGNORE)
Call by reference
	C++ - 
	void cppSwap ( int &a, int &b){
		int t =a;
		a = b ;
		b = t;
	}

	C -
	void cSwap (int *a, int *b){
		int t;
		t = *a;
		*a = *b;
		*b = t;
	}

	C# - The ref keyword in C# is used for passing or returning references of values to or from Methods. 
	Basically, it means that any change made to a value that is passed by reference will reflect this 
	change since you are modifying the value at the address and not just the value.

	Swap between 2 variables with no additional variable
	public static void Main(string[] args){
		int a = 10;
		int b = 5;
		Swap(ref a, ref b);
		Console.Writeline("A : " + a + ", B : " + b);
	}

	void Swap(ref int a, ref int b){
		a = a + b;
		b = a - b;
		a = a - b;
	}

C++ return by reference
	max(a,b) = -1;

	int &max(int &x, int *y)
	{
		if(x>y)
			return x;
		else
			return y;
	}
	Here if a is greater then -1 will be assigned
	else b will be assigned to -1;


Default argument
	func(int a, int b, int c = 1) 
	Restrictions
	1. Must be assigned to variables at the RHS end.
	2. If there are more than one then assigned in chain from the RHS end. like func(int a, int b, int c = 1, int d = 2)
	Helful
	1. When we dont want to pass any value for the parameter.

************************************************************************
(IGNORE)
Friend class 

C++ - A friend class can access private and protected members of other class in which it is declared as friend. 
It is sometimes useful to allow a particular class to access private members of other class.

	// C++ program to demonstrate the working of friend class

	#include <iostream>
	using namespace std;

	// forward declaration
	class ClassB;

	class ClassA {
		private:
			int numA;

			// friend class declaration
			friend class ClassB;

		public:
			// constructor to initialize numA to 12
			ClassA() : numA(12) {}
	};

	class ClassB {
		private:
			int numB;

		public:
			// constructor to initialize numB to 1
			ClassB() : numB(1) {}
    
		// member function to add numA
		// from ClassA and numB from ClassB
		int add() {
			ClassA objectA;
			return objectA.numA + numB;
		}
	};

	int main() {
		ClassB objectB;
		cout << "Sum: " << objectB.add();
		return 0;
	}


************************************************************************
(IGNORE)
C++ Friend Function

A friend function of a class is defined outside that class' scope but it has the right to access all private and protected members 
of the class. Even though the prototypes for friend functions appear in the class definition, friends are not member functions.

A friend can be a function, function template, or member function, or a class or class template, 
in which case the entire class and all of its members are friends.

To declare a function as a friend of a class, precede the function prototype in the class definition with keyword friend as follows −

	#include <iostream>
 
	using namespace std;
 
	class Box {
	   double width;
   
	   public:
		  friend void printWidth( Box box );
		  void setWidth( double wid );
	};

	// Member function definition
	void Box::setWidth( double wid ) {
	   width = wid;
	}

	// Note: printWidth() is not a member function of any class.
	void printWidth( Box box ) {
	   /* Because printWidth() is a friend of Box, it can
	   directly access any member of this class */
	   cout << "Width of box : " << box.width <<endl;
	}
 
	// Main function for the program
	int main() {
	   Box box;
 
	   // set box width without member function
	   box.setWidth(10.0);
   
	   // Use friend function to print the wdith.
	   printWidth( box );
 
	   return 0;
	}

************************************************************************

C# virtual method -
	
	It is a method that can be redefined in derived classes. 

	In C#, a virtual method has an implementation in a base class as well as derived the class. 

	It is used when a method's basic functionality is the same but sometimes more functionality 
	is needed in the derived class. A virtual method is created in the base class that can be 
	overriden in the derived class. We create a virtual method in the base class using the virtual keyword 
	and that method is overriden in the derived class using the override keyword.
 
	When a method is declared as a virtual method in a base class then that method can be defined in a base 
	class and it is optional for the derived class to override that method. The overriding method also provides 
	more than one form for a method. Hence it is also an example for polymorphism.
 
	When a method is declared as a virtual method in a base class and that method has the same definition 
	in a derived class then there is no need to override it in the derived class. But when a virtual method 
	has a different definition in the base class and the derived class then there is a need to override 
	it in the derived class.
 
	When a virtual method is invoked, the run-time type of the object is checked for an overriding member. 
	The overriding member in the most derived class is called, which might be the original member, 
	if no derived class has overridden the member.

Check : Virtual2.cs

************************************************************************

Classes and Structures have the following basic differences −

1.	classes are reference types and structs are value types
2.	structures do not support inheritance
3.	structures cannot have default constructor (but can have parameterized constructor)
4.	A struct object can be created with or without the new operator
5.	Structure members cannot be specified as abstract, virtual, or protected.

************************************************************************

C# Access Specifier

1.	Public
2.	Private
3.	Protected
4.	Internal
5.	Protected Internal
6.	Private Protected (Introduced in C# 7.2)

1.	Public - Can be accessed from anywhere. Its own class, derived, within the namespace/assembly or outside the namespace.
2.	Private - Can only be accessed only in the class it is declared.
3.	Protected - Can be accessed in its own class and its "directly" derived class only.
4.	Internal -	Can be accessed anywhere within its namespace only.
5.	Protected Internal - Can be thought as inheritance between 2 namespace using "protected" mode. 
	So internal in its own namespace 
	and protected in derived namespace.
6.	Private Protected - Here it is :
	Protected in its own namespace
	and private in derived namespace.

	In C# we inherit using the following format
	public class A{
		//Content
	}
	public class B : A {
	}

	Here we do not any access keyword of "Access Specifier" during inheritance rather whatever is the content inside the class 
	will be inherited according to its access specifier.

C# Default access specifier

If no access specifier is declared then the behaviour:
1.	The default is "Internal". So everything without any access specifier will be internal [With exception to members within the class].
2.	The members within a class without any access specifier will be "private" by default.

Static Modifier - The static modifier on a class means that the class cannot be instantiated, 
and that all of its members are static. 
A static member has one version regardless of how many instances of its enclosing type are created.

    static class Author {
 
        // Static data members of Author
        public static string A_name = "Ankita";
        public static string L_name = "CSharp";
        public static int T_no = 84;
 
        // Static method of Author
        public static void details()
        {
            Console.WriteLine("The details of Author is:");
        }
    }
 
    // Driver Class
    public class GFG {
 
        // Main Method
        static public void Main()
        {
 
            // Calling static method of Author
            Author.details();
 
            // Accessing the static data members of Author
            Console.WriteLine("Author name : {0} ", Author.A_name);
            Console.WriteLine("Language : {0} ", Author.L_name);
            Console.WriteLine("Total number of articles : {0} ", Author.T_no);
        }
    }


Sealed classes - They are used to restrict the inheritance feature of object oriented programming. 
Once a class is defined as a sealed class, this class cannot be inherited. 
In C#, the sealed modifier is used to declare a class as sealed. In Visual Basic .NET, NotInheritable keyword serves the purpose of sealed. 
If a class is derived from a sealed class, compiler throws an error.
Structs can also be sealed.
	
A sealed class, in C#, is a class that cannot be inherited by any class but can be instantiated. 
The design intent of a sealed class is to indicate that the class is specialized and there is no need
to extend it to provide any additional functionality through inheritance to override its behavior.

	Purpose of Sealed Classes
	We just saw how to create and use a sealed class in C#. 
	The main purpose of a sealed class is to take away the inheritance feature from the class users 
	so they cannot derive a class from it. One of the best usage of sealed classes 
	is when you have a class with static members. For example, the Pens and Brushes classes of the System.Drawing namespace.

	The Pens class represents the pens with standard colors. 
	This class has only static members. For example, Pens.Blue represents a pen with blue color. 
	Similarly, the Brushes class represents standard brushes. The Brushes.Blue represents a brush with blue color.


	// Sealed class  
	sealed class SealedClass  
	{  
	}   

    //Another example
	class X  
    {  
        protected virtual void F()  
        {   
            Console.WriteLine("X.F");   
        }  
        protected virtual void F2()  
        {  
            Console.WriteLine("X.F2");   
        }  
    }  
    class Y : X  
    {  
        sealed protected override void F()  //Sealed
        {  
            Console.WriteLine("Y.F");  
        }  
        protected override void F2()  
        {  
            Console.WriteLine("X.F3");  
        }  
    }  
    class Z : Y  
    {  
        // Attempting to override F causes compiler error CS0239.  
        //   
        protected override void F()  
        {  
             Console.WriteLine("C.F");   
        }  
        // Overriding F2 is allowed.   
        protected override void F2()  
        {  
            Console.WriteLine("Z.F2");   
        }  
    }  

************************************************************************

Types of Inheritance

1.  Single inheritance
2.  Multi-level inheritance
3.  Multiple inheritance
4.  Multipath inheritance
5.  Hierarchical Inheritance
6.  Hybrid Inheritance

1.  Single - Here a single class is derived from base class.
    Ex -
    class A{}
    class B: A{}

2.  Multi-Level - Here a class can be derived from another derived class.
    Ex -
    class A{}
    class B: A{}
    class C: B{}

3.  Multiple - Here derived class can have more than one base class. In .net we use interface for the same
    interface A{}
    interface B{}
    interface C : A, B
    
    Cause of avoiding multiple inheritance in C# - This is Cause by diamond Shape problems of two classes 
    If two classes B and C inherit from A, and class D inherits from both B and C. 
    A          
    B,C
    D
    If a method in D calls a method defined in A (and does not override it), and B and C have overridden that method differently, 
    then via which class does it inherit: B, or C? 
    So., multiple inheritance is not possible in C#. that is called Diamond Problem. 
    But., in C# we can solve the Diamond problem with the help of interfaces in some cases.

4.  Multipath - Here we have the diamond structure. Not possible in C#
    class A{}
    class B:A{}
    class C:A{}
    class D: B,C {}

5.  Hierchical - Multiple classes are derived from one base class. This is needed when we need the feature of base class 
    in all the other class.

    class A{}
    
    class B: A{}
    class C: B{}
    class D: B{}

    class E: A{}
    class F: E{}
    class G: E{}

6. Hybrid - Any combination of existing type of inheritance.

************************************************************************

Final vs Finalize vs Finally (with respect to Java)

Final - (In C# it is called sealed) It applies restriction to a class. Can be used with class, method and variables.
        Final class cannot be inherited.
        Final method cannot be overridden by sub-class.
        Final variables once declared they become constant that is they cannot be changed.

        This is not available in C# and written with respect to java.
        For C# we can use sealed keyword with class and method.
        For variables we can use const and readonly. So that values cannot be changed. [Const vs Readonly in below block]

Finally - This works with try catch blocks.
        Once try throws an error it will be received by catch block. Once that exception handling is done, the 
        finally block will be executed. That is whether the control is in try or catch still finally will be executed.
        If declared it will always be executed. Even if the code inside the finally block has any exception it will
        still be run. This exception can be handled using some other external try catch blocks.
        It will be used for clean up purpose. ex - any variables declared will be cleaned, or any opened file will 
        be closed.

        try{}
        catch(){}
        finally{}

        What will happen if exception is encountered in Finally block?
        Ans - The exception propagates out and can be handled at upper level.
        The finally block will not be completed once it hits the exception.
        If there is an existing exception in try block (and not handled in immediate catch block) 
        and then this finally block encounters the exception then the try block exception will be lost.

        Ex - 
        Case 1

        using System;

        class Program
        {
            static void Main(string[] args)
            {
                try
                {
                    try
                    {
                        throw new Exception("exception thrown from try block");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("Inner catch block handling {0}.", ex.Message);
                        throw;
                    }
                    finally
                    {
                        Console.WriteLine("Inner finally block");
                        throw new Exception("exception thrown from finally block");
                        Console.WriteLine("This line is never reached");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Outer catch block handling {0}.", ex.Message);
                }
                finally
                {
                    Console.WriteLine("Outer finally block");
                }
            }
        }

        Output -
        Inner catch block handling exception thrown from try block. <------------------
        Inner finally block
        Outer catch block handling exception thrown from finally block.
        Outer finally block

        Case 2

        using System;

        class Program
        {
            static void Main(string[] args)
            {
                try
                {
                    try
                    {
                        throw new Exception("exception thrown from try block");
                    }
                    finally
                    {
                        Console.WriteLine("Inner finally block");
                        throw new Exception("exception thrown from finally block");
                        Console.WriteLine("This line is never reached");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Outer catch block handling {0}.", ex.Message);
                }
                finally
                {
                    Console.WriteLine("Outer finally block");
                }
            }
        }

        Output - 
        <Try block exception information lost as not handled in catch> <------------------
        Inner finally block 
        Outer catch block handling exception thrown from finally block.
        Outer finally block



Finalize - This will be used for garbage collection purpose. It will be used before obect is destroyed. They are implemented using destructors.
        
************************************************************************

Const VS readonly

Ex : 
public const double x=1.0, y=2.0, z=3.0;
public static readonly uint l1 = (uint) DateTime.Now.Ticks;

Readonly - Runtime constant. i.e on execution of a statement the value will be stored and that value wont be changed.
        Ex - readonly int a1 = (a + b) * c; // After execution a1 value can't be changed throughout the execution.
        Cannot be declared inside the method of the class.

Const - Compiletime constant. i.e that is values will be predefined.

************************************************************************

Managed and Unmanaged Code 

Managed Code - Created and handled by CLR (Common language runtime). Well handled by Garbage collector.
Unmanage Code - Not controlled by CLR. Garbage collector cannot totally handle this code.

************************************************************************

C# finalize, dispose, destructors, and garbage collection

Destructor - It is a method inside a class to destroy instances of a class when they are no longer needed.
            It is implicitly called by .net Garbage Collector so it will be automatically called even if 
            we are not implementing it.

            Though we can declare it to have some added control.
            Syntax - ~<Destroctor name>.
            Ex -
            class MyClass{
                public MyClass(){}  //Constructor
                ~MyClass() {}       //Destructor - No parameter or Access specifier
            }

Garbage Collection - 
    GC manages the allocation and release of memory. It serves as an automatic memory manager. We do not need to 
    track the allocation and release of memory.
    Allocation will be done with use of 'new' keyword.
    When execution is completed or when there isn't enough memory to allocate an object, the GC must collect and
    dispose of garbage memory to make memory available for new allocations.

    Features-
            -   GC keep tracks of all the objects and ensures that each object get destroyed once.
            -   GC ensures that objects, which are being referenced are not destroyed.
            -   GC destroys the object only when necessary. We can explicity call System.GC.Collect() to invoke garbage collector
         
         
C# - Finalize (or Destructors) vs Dispose -
    Unamanged Code in C# will be handled using Dispose().

    Finalize
    -   Now Finalize is created using the Destructors.
    -   Generally it will be controlled by GC. So there is less control when finalize will be called.
    -   Will clean the managed code only.

    Dispose 
    -   Dispose is used by calling Dispose().
    -   Dispose can be called explicitly call to release resource both managed + unmanaged. So if dispose is called its 
    better we should not call the GC (or finalize again).
    -   To implement the class must inherit from "IDisposable" interface.

    Dispose Implementation

    //Microsoft recommended
    class ReadFileClass : IDisposable
    {
        Boolean disposed = false;

        public void Dispose()
        {
            Dispose(true); //Freeing both Managed + Unmanaged Resource
            GC.SuppressFinalize(this); //Suppressing Freeing of Managed Resource Again
        }

        //If disposing is false then only unmanaged code will be cleaning
        protected virtual void Dispose(boolean disposing)
        {
            if (disposed) 
                return;

            if (disposing)
            {
                Console.WriteLine("Freeing Managed Resource");
            }

            Console.WriteLine ("Freeing Unmanaged Resource");
        
            disposed = true;
        }
    }

 NOTE - Next iteration SafeHandle.Dispose use 
 https://www.youtube.com/watch?v=6_Upud25iFQ
 https://dzone.com/articles/when-and-how-to-use-dispose-and-finalize-in-c

************************************************************************

Ref vs Out

Ref and Out keyword will be utilized for using as reference variable.

For ref it has to be initialized to be updated with new data.
For out we can simply assign value to it without initializing with data.

    Ref Example :

    public static string GetNextName(ref int id)
    {
        string returnText = "Next-" + id.ToString();
        id += 1;
        return returnText;
    }
    static void Main(string[] args)
    {
        int i = 1;
        Console.WriteLine("Previous value of integer i:" + i.ToString());
        string test = GetNextName(ref i);
        Console.WriteLine("Current value of integer i:" + i.ToString());
    }

    Out Example :

    public static string GetNextNameByOut(out int id)
    {
        id = 1;
        string returnText = "Next-" + id.ToString();
        return returnText;
    }
    static void Main(string[] args)
    {
        int i = 0;
        Console.WriteLine("Previous value of integer i:" + i.ToString());
        string test = GetNextNameByOut(out i);
        Console.WriteLine("Current value of integer i:" + i.ToString());
    }

************************************************************************

Serialize vs Deserialize

Serialize - Copy data from object to file. Object to stream. Ex - JSON to string 
Deserialize - Copy file data to object. Stream to object. Ex - string to JSON.

************************************************************************

What is the difference between Array and Arraylist?
In an array, we can have items of the same type only. The size of the array is fixed when compared. 
To an arraylist is similar to an array, but it doesn’t have a fixed size and can take any data.

Array is fast and arraylist is slow due to boxing-unboxing.

Array - 

int[] intArray = new int[5];
intArray[0] = 10;
intArray[1] = 20;
// ...

ArrayList - 

using System.Collections;

ArrayList arrayList = new ArrayList();
arrayList.Add(10);
arrayList.Add("Hello");


************************************************************************

What are the differences between System.String and System.Text.StringBuilder classes?
System.String is immutable. When we modify the value of a string variable, then a new memory is allocated 
to the new value and the previous memory allocation released. System.StringBuilder was designed to have a 
concept of a mutable string where a variety of operations can be performed without allocation separate 
memory location for the modified string.

************************************************************************

What is Boxing and Unboxing in C#? 
 
Boxing and Unboxing both are used for type conversions.
 
The process of converting from a value type to a reference type is called boxing. 
Boxing is an implicit conversion. Here is an example of boxing in C#.
    // Boxing  
    int anum = 123;  
    Object obj = anum;  
    Console.WriteLine(anum);  
    Console.WriteLine(obj); 


The process of converting from a reference type to a value type is called unboxing. Here is an example of unboxing in C#.
    // Unboxing  
    Object obj2 = 123;  
    int anum2 = (int)obj;  
    Console.WriteLine(anum2);  
    Console.WriteLine(obj);  

************************************************************************

Can “this” be used within a static method?
 
We can't use 'this' in a static method because the keyword 'this' returns a reference to the current instance of the class containing it. 
Static methods (or any static member) do not belong to a particular instance. They exist without creating an instance of the class 
and are called with the name of a class, not by instance, so we can’t use this keyword in the body of static Methods. However, 
in the case of Extension Methods, we can use the parameters of the function.
Let’s have a look at the “this” keyword.

************************************************************************

Extension methods in C#?
 
Extension methods enable you to add methods to existing types without creating a new derived type, recompiling, 
or otherwise modifying the original type. 

************************************************************************































