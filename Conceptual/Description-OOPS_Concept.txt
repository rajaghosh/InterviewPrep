OOPS - Object-Oriented Programming System

    Features
        1. Emphasis on Data rather than procedure.
        2. Data security
        3. Follows bottom-up approach. 
	    Here in this approach the modules are designed individually and are then integrated together to complete the design.
	    Advantage - Testing and Reusability gets easier.
	    While the top-down approach focusses on breaking down a bigger problem into smaller and understandable chunk, the 
	    bottom-up approach first focusses on solving the smaller problems at the fundamental level and then integrating them 
	    into whole and complete solution.

    Properties
        1.	Classes and Objects.
        2.	Data abstraction and encapsulation - Wrapping up of data and functions into a single unit (called class) is known 
	        as "encapsulation". The data is generally not accessible to outside world and methods inside the class can access it.
	        So the methods form the medium through which data can be exchanged between object and the program. This insulation from
	        direct access by the program is called "data hiding".
	        Abstraction referes to the act of representing essential features without including the background details or explanations.
	        Since classes use the concept of data abstraction they are known as Abstract Data types.
        3.	Inheritance - It is the process by which one class acquire the properties of objects of another class.
        4.  Polymorphism - Same name but different logic. Ex - Method overloading : Here we can have multiple methods of same name 
	        but different parameters. Ex - Operator Overloading : Operator exhibit different behavior in diff instances.
        5.	Dynamic Binding - Also called late binding. Here the code associated with a given procedure call is not known till the 
	        code is run or at instantiation.

----------------------------------------------------------------------------------------

Data Types

    1. Built-in Types - 
        a. Integral Types - int, char
        b. void
        c. Floating - float, double
    2. User-Defined - 
        Structure, Union, Class, enum
    3. Derived - 
        sArray, function, pointer, reference

----------------------------------------------------------------------------------------

PascalCase vs camelCase

    Pascal case and camel case are two popular naming conventions used in programming to improve code readability and maintainability. 
    Here’s a quick comparison:

    Pascal Case
        a. Format: Each word in the identifier starts with an uppercase letter.
        b. Example: FirstName, LastName, DateOfBirth
        c. Usage: Commonly used for naming classes, interfaces, and namespaces in languages like C#, Java, and JavaScript.
    
    Camel Case
        a. Format: The first word starts with a lowercase letter, and each subsequent word starts with an uppercase letter.
        b. Example: firstName, lastName, dateOfBirth
        c. Usage: Often used for naming variables, methods, and functions in languages like JavaScript, Python, and Ruby.

----------------------------------------------------------------------------------------

Reference Variable - 
    
    Its an alias to the original variable. The reference variable and the original variable will share the same memory space.
	    Ex : float total = 100;
			 float &sum = total;

Type cast in C# 
	Ex int a = (int) 1.01;

----------------------------------------------------------------------------------------

C# virtual method -
	
	It is a method that can be redefined in derived classes. In C#, a virtual method has an implementation in a base class as 
    well as derived the class. 

	It is used when a method's basic functionality is the same but sometimes more functionality is needed in the derived class. 
    A virtual method is created in the base class that can be overriden in the derived class. We create a virtual method in the
    base class using the virtual keyword and that method is overriden in the derived class using the override keyword.
 
	When a method is declared as a virtual method in a base class then that method can be defined in a base class and it is optional 
    for the derived class to override that method. The overriding method also provides more than one form for a method. Hence it is 
    also an example for polymorphism.
 
	When a method is declared as a virtual method in a base class and that method has the same definition in a derived class then there
    is no need to override it in the derived class. But when a virtual method has a different definition in the base class and the 
    derived class then there is a need to override it in the derived class.
 
	When a virtual method is invoked, the run-time type of the object is checked for an overriding member. The overriding member in the 
    most derived class is called, which might be the original member, if no derived class has overridden the member.

Check : Virtual2.cs

----------------------------------------------------------------------------------------

Classes and Structures have the following basic differences −

    1. Classes are reference types and structs are value types
    2. Structures do not support inheritance
    3. Structures cannot have default constructor (but can have parameterized constructor)
    4. A struct object can be created with or without the new operator
    5. Structure members cannot be specified as abstract, virtual, or protected.

----------------------------------------------------------------------------------------

C# Access Specifier

    1. Public - Can be accessed from anywhere. Its own class, derived, within the namespace/assembly or outside the namespace.
    
    2. Private - Can only be accessed only in the class it is declared.
    
    3. Protected - Can be accessed in its own class and its "directly" derived class only.
    
    4. Internal -	Can be accessed anywhere within its namespace only.
    
    5. Protected Internal - Can be thought as inheritance between 2 namespace using "protected" mode. 
	    So internal in its own namespace and protected in derived namespace.
    
    6. Private Protected (Introduced in C# 7.2) - Here it is :
        Protected in its own namespace and private in derived namespace.

	    In C# we inherit using the following format
	    public class A{
		    //Content
	    }
	    public class B : A {
	    }

	Here we do not any access keyword of "Access Specifier" during inheritance rather whatever is the content inside the class 
	will be inherited according to its access specifier.

----------------------------------------------------------------------------------------

C# Default access specifier

    If no access specifier is declared then the behaviour:
    1.	The default is "Internal". So everything without any access specifier will be internal [With exception to members within the class].
    2.	The members within a class without any access specifier will be "private" by default.

    Static Modifier - The static modifier on a class means that the class cannot be instantiated, and that all of its members are static. 
    A static member has one version regardless of how many instances of its enclosing type are created.

        static class Author {
 
            // Static data members of Author
            public static string A_name = "Ankita";
            public static string L_name = "CSharp";
            public static int T_no = 84;
 
            // Static method of Author
            public static void details()
            {
                Console.WriteLine("The details of Author is:");
            }
        }
 
        // Driver Class
        public class GFG {
 
            // Main Method
            static public void Main()
            {
 
                // Calling static method of Author
                Author.details();
 
                // Accessing the static data members of Author
                Console.WriteLine("Author name : {0} ", Author.A_name);
                Console.WriteLine("Language : {0} ", Author.L_name);
                Console.WriteLine("Total number of articles : {0} ", Author.T_no);
            }
        }

----------------------------------------------------------------------------------------

Sealed classes 
    
    They are used to restrict the inheritance feature of object oriented programming. Once a class is defined as a sealed class, this 
    class cannot be inherited. In C#, the sealed modifier is used to declare a class as sealed. In Visual Basic .NET, NotInheritable 
    keyword serves the purpose of sealed. 
    If a class is derived from a sealed class, compiler throws an error. Structs can also be sealed.
	
    A sealed class, in C#, is a class that cannot be inherited by any class but can be instantiated. The design intent of a sealed class 
    is to indicate that the class is specialized and there is no need to extend it to provide any additional functionality through inheritance 
    to override its behavior.

	Purpose of Sealed Classes
	    a. We just saw how to create and use a sealed class in C#. 
	    b. The main purpose of a sealed class is to take away the inheritance feature from the class users so they cannot derive a class from it. 
        One of the best usage of sealed classes is when you have a class with static members. 
        For example, the Pens and Brushes classes of the System.Drawing namespace.

	The Pens class represents the pens with standard colors. 
	This class has only static members. For example, Pens.Blue represents a pen with blue color. 
	Similarly, the Brushes class represents standard brushes. The Brushes.Blue represents a brush with blue color.


	    // Sealed class  
	    sealed class SealedClass  
	    {  
	    }   

        //Another example
	    class X  
        {  
            protected virtual void F()  
            {   
                Console.WriteLine("X.F");   
            }  
            protected virtual void F2()  
            {  
                Console.WriteLine("X.F2");   
            }  
        }  
        class Y : X  
        {  
            sealed protected override void F()  //Sealed
            {  
                Console.WriteLine("Y.F");  
            }  
            protected override void F2()  
            {  
                Console.WriteLine("X.F3");  
            }  
        }  
        class Z : Y  
        {  
            // Attempting to override F causes compiler error CS0239.  
            //   
            protected override void F()  
            {  
                 Console.WriteLine("C.F");   
            }  
            // Overriding F2 is allowed.   
            protected override void F2()  
            {  
                Console.WriteLine("Z.F2");   
            }  
        }  

----------------------------------------------------------------------------------------

Types of Inheritance
    
    1. Single Inheritance - Here a single class is derived from base class.
        Ex -
        class A{}
        class B: A{}

    2. Multi-Level Inheritance - Here a class can be derived from another derived class.
        Ex -
        class A{}
        class B: A{}
        class C: B{}

    3. Multiple Inheritance - Here derived class can have more than one base class. In .net we use interface for the same
        interface A{}
        interface B{}
        interface C : A, B
    
        Cause of avoiding multiple inheritance in C# - 
        This is Cause by Diamond Shape problems of two classes. If two classes B and C inherit from A, and class D inherits from both B and C. 
            A
           / \
          B   C
           \ /
            D
        
        If a method in D calls a method defined in A (and does not override it), and B and C have overridden that method differently, 
        then via which class does it inherit: B, or C? 
        So., multiple inheritance is not possible in C#. that is called Diamond Problem. 
        But., in C# we can solve the Diamond problem with the help of interfaces in some cases.

    4. Multipath Inheritance - Here we have the diamond structure. Not possible in C#
        class A{}
        class B:A{}
        class C:A{}
        class D: B,C {}

    5. Hierchical Inheritance - Multiple classes are derived from one base class. This is needed when we need the feature of base class 
    in all the other class.

        class A{}
    
        class B: A{}
        class C: B{}
        class D: B{}

        class E: A{}
        class F: E{}
        class G: E{}

    6. Hybrid Inheritance - Any combination of existing type of inheritance.

----------------------------------------------------------------------------------------

Final vs Finalize vs Finally (with respect to Java)

    Final - (In C# it is called sealed) 
        a. It applies restriction to a class. Can be used with class, method and variables.
        b. Final class cannot be inherited.
        c. Final method cannot be overridden by sub-class.
        d. Final variables once declared they become constant that is they cannot be changed.

        This is not available in C# and written with respect to java.
        For C# we can use sealed keyword with class and method.
        For variables we can use const and readonly. So that values cannot be changed. [Const vs Readonly in below block]

    Finally - This works with try catch blocks.
        Once try throws an error it will be received by catch block. Once that exception handling is done, the 
        finally block will be executed. That is whether the control is in try or catch still finally will be executed.
        If declared it will always be executed. Even if the code inside the finally block has any exception it will
        still be run. This exception can be handled using some other external try catch blocks.
        It will be used for clean up purpose. ex - any variables declared will be cleaned, or any opened file will 
        be closed.

        try{}
        catch(){}
        finally{}

        What will happen if exception is encountered in Finally block?
        Ans - The exception propagates out and can be handled at upper level.
        The finally block will not be completed once it hits the exception.
        If there is an existing exception in try block (and not handled in immediate catch block) 
        and then this finally block encounters the exception then the try block exception will be lost.

        Ex - 
        Case 1

        using System;

        class Program
        {
            static void Main(string[] args)
            {
                try
                {
                    try
                    {
                        throw new Exception("exception thrown from try block");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine("Inner catch block handling {0}.", ex.Message);
                        throw;
                    }
                    finally
                    {
                        Console.WriteLine("Inner finally block");
                        throw new Exception("exception thrown from finally block");
                        Console.WriteLine("This line is never reached");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Outer catch block handling {0}.", ex.Message);
                }
                finally
                {
                    Console.WriteLine("Outer finally block");
                }
            }
        }

        Output -
        Inner catch block handling exception thrown from try block. <------------------
        Inner finally block
        Outer catch block handling exception thrown from finally block.
        Outer finally block

        Case 2

        using System;

        class Program
        {
            static void Main(string[] args)
            {
                try
                {
                    try
                    {
                        throw new Exception("exception thrown from try block");
                    }
                    finally
                    {
                        Console.WriteLine("Inner finally block");
                        throw new Exception("exception thrown from finally block");
                        Console.WriteLine("This line is never reached");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine("Outer catch block handling {0}.", ex.Message);
                }
                finally
                {
                    Console.WriteLine("Outer finally block");
                }
            }
        }

        Output - 
        <Try block exception information lost as not handled in catch> <------------------
        Inner finally block 
        Outer catch block handling exception thrown from finally block.
        Outer finally block

    Finalize - This will be used for garbage collection purpose. It will be used before obect is destroyed. They are implemented using destructors.
        
----------------------------------------------------------------------------------------

Const VS readonly

    Ex : 
    public const double x=1.0, y=2.0, z=3.0;
    public static readonly uint l1 = (uint) DateTime.Now.Ticks;

    Readonly - Runtime constant. i.e on execution of a statement the value will be stored and that value wont be changed.
            Ex - readonly int a1 = (a + b) * c; // After execution a1 value can't be changed throughout the execution.
            Cannot be declared inside the method of the class.

    Const - Compiletime constant. i.e that is values will be predefined.

----------------------------------------------------------------------------------------

Ref vs Out

    Ref and Out keyword will be utilized for using as reference variable.

    For ref it has to be initialized to be updated with new data.
    For out we can simply assign value to it without initializing with data.

    Ref Example :

    public static string GetNextName(ref int id)
    {
        string returnText = "Next-" + id.ToString();
        id += 1;
        return returnText;
    }
    static void Main(string[] args)
    {
        int i = 1;
        Console.WriteLine("Previous value of integer i:" + i.ToString());
        string test = GetNextName(ref i);
        Console.WriteLine("Current value of integer i:" + i.ToString());
    }

    Out Example :

    public static string GetNextNameByOut(out int id)
    {
        id = 1;
        string returnText = "Next-" + id.ToString();
        return returnText;
    }
    static void Main(string[] args)
    {
        int i = 0;
        Console.WriteLine("Previous value of integer i:" + i.ToString());
        string test = GetNextNameByOut(out i);
        Console.WriteLine("Current value of integer i:" + i.ToString());
    }

----------------------------------------------------------------------------------------

What are the differences between System.String and System.Text.StringBuilder classes?

    System.String is immutable. When we modify the value of a string variable, then a new memory is allocated to the new value and the previous
    memory allocation released.
    
    System.StringBuilder was designed to have a concept of a mutable string where a variety of operations can be performed without allocation separate 
    memory location for the modified string.

----------------------------------------------------------------------------------------

Can “this” be used within a static method?
 
    We can't use 'this' in a static method because the keyword 'this' returns a reference to the current instance of the class containing it. 
    Static methods (or any static member) do not belong to a particular instance. They exist without creating an instance of the class and are
    called with the name of a class, not by instance, so we can’t use this keyword in the body of static Methods. However, in the case of 
    Extension Methods, we can use the parameters of the function. 

----------------------------------------------------------------------------------------



































