----------------------------------------------------------------------------------------------------

In dot net core when deployed in Azure App Service whatever config settings present launchSettings.
Json can be configured individually in the "Configuration" option of AppService.


Middleware - It is a method which can intercept a Httprequest/Httpresponse and then do some work and provide response.
Typically total of all middlewares combined + some other methods form the .net core pipeline.

The order of the Middleware is important.

Middlewares are chained one after another, so they have choice whether to work with the request or pass it to next middleware 
component. (And also to perform work before and after the next component).

In the startup class the ConfigureServices() is not mandatory but Configure() is mandatory.

Typically the flow is 
Request -> Middleware -> Controller -> Middleware -> Response

Generally order of Middleware is 
	ExceptionHandler
	HSTS
	HttpsRedirection
	Static Files
	Routing
	CORS
	Authentication
	Authorization
	Session
	RazorFiles
	Custom Middlewares

----------------------------------------------------------------------------------------------------

App.Run() -
	To execute a basic middleware, from the Configure() we have an instance of "IApplicationBuilder" as app.
	so, we have a method app.Run() - this will execute any incoming request.

	ex : app.Run(await p => await p.Response.WriteAsync("Hello World!"));

	So with help of delegate we are executing and returing a response. The above example can be thought as an inline middleware
	as we have returned inline.

	So the app.Run() receives a httprequest and it does not know about next middleware.
	This middleware where we get end result as called terminal middlewares as the request/response operation stops here.
	Typically we use app.Run() to indicate end of pipeline.

	So, app.Run() //1 - Will be invoked and pipeline will exit
		app.Run() //2 - Will not work.

	Run() is an extension method

App.Use() -
	ex:

		app.Use(aync(context, next) => {
			Console.WriteLine("1-Before Request");
			await next();
			Console.WriteLine("3-After Request");
		});

		app.Run(aync context => {
			Console.WriteLine("2-In app.Run");
			await contest.Response.WriteAsync("Hello World!");
		});


	Here we have 2 o/p - 
	a. On the webpage -> Hello World!
	b. On the console -> 
		1-Before Request
		2-In app.Run
		3-After Request

	So we can find middleware chaining here.
	Note - x`Here next() and next.Invoke() and next(context) and next.Invoke(context) are same.

	So we can think of 1st middleware is adding to next middleware. 

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

Definition for Interview purpose -

Q. What is a request delegate?
Request delegate are used to build the request pipeline. So a httpRequest is coming inside the configure() and then it is visiting
middleware1 -> middleware2 -> last middleware and response -> middleware2 -> middleware1
This flow forms the request pipeline.

Now request delegate handle request ppipeline using the extension methods Use(), Run(), and Map()


In .net core middleware we have delegate(run, use, and map) assembled into an application pipeline to handle requests and responses. 
Middleware is a chain to pass the request to the next component or not and also perform work before and after the next component.

	1. app.Use() - To introduce a new middleware. The Use() extension method will execute the next middleware or line in sequence.
	Typically the format is 
	
		app.Use({
			//Some work-1
			next();
			//Some work-3
		});
		app.Use({
			//Some work-2
			next();
		});
		app.Run({
	
		});

	So o/p is:
	Some work-1
	Some work-2
	Some work-3

	By convention all available Middlewares with Use prefix are using Use() extension method. Ex-> app.UseRouting();

	Another important concept is if we have a app.Use() with no next() and a app.Run() then app.Run() will not execute
	app.Use({
		//No next();
	});
	app.Run({
	
	});
	Here app.Run() will not be hit and request will produce response from app.Use() only.


	2. app.Run() - The Run() extension method will terminate the middleware chaining. No other middlewares will run after this.
	This should be placed at the end of the pipeline.

	3. app.Map() - The Map() extension method will be used to match request delegates based upon request URL path.

	app.Use({aync (context, next) =>
	{
		await context.Response.WriteAsync("Output1");
		await next();
	});
	app.Map("/myPath", a => {
		a.Run(async(context) => {
			await context.Response.WriteAsync("Output2");	
		})
	});

	Here if our request url has /myPath then only the next middleware will run.

**************************************************************************************************************************

Creating a Custom Middleware -

	We can have multiple ways to create custom middlewares. We are writing the simple version here. 
	The middleware will be used to put custom logic on httpRequest

	1. Create a Middleware Folder -> CustomMiddleware.cs file

	public class CustomMiddleware
	{
		private readonly RequestDelegate _next;

		public CustomMiddleware(RequestDelegate next)
		{
			_next = next;
		}

		//Standard format (Important to keep it like this)
		public Task Invoke(httpContext context)
		{
			//Do our task

			return _next(context);
		}
	}

	2. In the startup.cs class
	After all the middleware executed in Configure()
	
	app.UseMiddleware<CustomMiddleware>();

************************************************************************************************************************

AddSingleton vs AddScoped vs AddTransient

In .NET Core (now known as .NET 5 and later versions), there are three main lifetime options for registering services 
with the built-in dependency injection container: Singleton, Scoped, and Transient. 
These lifetimes determine how instances of the registered services are managed and shared within the application. 
Let's explore each of these lifetimes:

Singleton:

Services registered with a singleton lifetime are only instantiated once during the lifetime of the application. 
This means that any injection of the service during the lifetime of the application will be done with the same
instance of the service. In other words, only one service instance is created and shared across all requests.

Scoped:

Services registered with a scoped lifetime will be maintained and used during the lifetime of the scope 
(or HTTP request) they have been created in. So for one same request, the instance of an object injected 
in different classes will be the same. In simple words, one service instance is created for each request 
and reused throughout the request.

Transient:

Instances of services registered with a transient lifetime are created every time that their injection 
into a class is required even though it is the same request.

Here are some general guidelines:

Singleton: Use when the service instance should be shared globally across the entire application 
and maintain state that is consistent throughout the application's lifetime.

Scoped: Use in scenarios like web applications, where you want to ensure that data is isolated within 
the scope of a single request. Scoped services are often used to manage per-request database connections 
or user-specific data.

Transient: Use for stateless, short-lived services that don't need to maintain any long-term state. 
Transient services are created each time they're requested, which can be suitable for lightweight processing.




------------------------------------------------------------------------------------------------------------------------
CORS Website whitelisting

Services.AddCors() use AddPolicy() delegate.

services.AddCors(options =>
{
    options.AddPolicy(name: CORSPolicyProd,
    builder =>
      {
          builder.WithOrigins("https://localhost:5001",
                              "https://localhost:5000",
                              "https://telemedicine.frontlinemds.com",
                              "http://ec2-54-89-28-147.compute-1.amazonaws.com",
                              "https://marketplace.drstellamd.com")
          .AllowAnyHeader()
          .AllowAnyMethod()					//For specific method .WithMethods("GET","POST","PATCH","DELETE")
		  .WithExposedHeaders("Content-disposition", "WWW-Authenticate");
      }
    );
});


-----------------------------------------------------------------------------------------------------------------------
WebApi different types of attributes

1. [AllowAnonymous] - Allow request without any token
2. [HttpGet("<ApiName>")]
3. [Authorize(Roles = "Admin")] - Authorize filter
4. [ProducesResponseType(typeof(FileContentResult), (int)HttpStatusCode.Ok)] - It is filter that will specify type of 
value and status code returned by the ActionMethod.
Ex. 
[ProducesResponseType(typeof(FileContentResult), (int)HttpStatusCode.OK)]
[ProducesResponseType(typeof(FileContentResult), (int)HttpStatusCode.NotFound)]

This resembles the API can return 2 types of responses

4b. [Produces(MediaTypeNames.Application.Json)]
5. ActionMethod([FromQuery(Name="lang")] string lang) - Specifies that a parameter or property should be bound using 
the request query string.
6. [FromRoute][UrlSlug] - Here UrlSlug acts as a ValidationAttribute and can be used in the parameter list
	We can also have [FormQuery, Required]
7. [FromBody][Bind("Property1","Property2")] - From all the property take only specific property of the DTO
8. [FromBody][MaxLength(50)]
9. [ResponseCache(Duration = 600, Location = ResponseCacheLocation.Client, NoStore = false)] -








-----------------------------------------------------------------------------------------------------------------------

Filters in .net core -

Filters gives us the facility to run a piece of code before or after any stage in request processing pipeline. 
Filters have benefits like
- Reusability
- Extensibility

Types of Filters

Authorization Filters : 
* Run first.
* Determine whether the user is authorized for the request.
* Short-circuit the pipeline if the request is not authorized.

Resource Filters : 
* Run after authorization.
* OnResourceExecuting runs code before the rest of the filter pipeline. 
For example, OnResourceExecuting runs code before model binding.
* OnResourceExecuted runs code after the rest of the pipeline has completed.

Action Filters : 
* Run immediately before and after an action method is called.
* Can change the arguments passed into an action.
* Can change the result returned from the action.
* Are not supported in Razor Pages.

Endpoint filters:
* Run immediately before and after an action method is called.
* Can change the arguments passed into an action.
* Can change the result returned from the action.
* Are not supported in Razor Pages.
* Can be invoked on both actions and route handler-based endpoints.

Exception filters
* Apply global policies to unhandled exceptions that occur before the response body has been written to.

Result filters:
* Run immediately before and after the execution of action results.
* Run only when the action method executes successfully.
* Are useful for logic that must surround view or formatter execution.


-----------------------------------------------------------------------------------------------------------------------
Rahul Nath

Filters in .net core allows code to run before or after specific stages in request processing pipleline.
We can have built in filters like authorization and response caching. We can also have custom filters

 Filters run within the Asp.Net core Action Invocation Pipeline or Filter pipeline. The filter pipeline runs after the 
 ASP.Net selects the action to execute.

 Flow:
 HttpRequest 
 -> All Middleware 
 -> Routing Middleware 
 -> ActionSelection (Controller invoke) this will invoke the filters ---- MVC Action Invocation Pipeline (Filter Pipeline).<-
 -> Routing Middleware 
 -> All Middleware 

 So here filters get executed before and after the actions

-------------------------
 Creating custom filter at GLOBAL LEVEL

 Step 1 : Create a custom filter class

	//Creating custom action filter
	public class MyCustomActionFilter : IActionFilter	//This interface has 2 methods to be implemented OnActionExecuting and OnActionExecuted
	{
		public void OnActionExecuting(ActionExecutingContext context){
			Console.WriteLine("On Action Executing");
		}
	
		public void OnActionExecuted(ActionExecutedContext context){
			Console.WriteLine("On Action Executed");
		}
	
	}

 Step 2 : To integrate this custom filter into .net Request Pipeline
 In the Startup.cs 

	public void ConfigureServices(IServiceCollection services){
	
		//We will use AddController Method has a overloaded version we will use that
		services.AddControllers( options =>
		{
			options.Filters.Add(new MyCustomActionFilter());
		});
	}

This will integrate the custom filter for all the httpRequest. That is custom filter at global level

-------------------------CUSTOM FILTER AT CONTROLLER AND METHOD LEVEL

To implement filter at controller level we need to using attributes.

Changes in code in step 1 we also inherit from Attribute

 Step 1 : Create a custom filter class

	//Creating custom action filter Attribute ending with attribute 
	public class MyCustomActionFilterAttribute : Attribute, IActionFilter	
	{

		private readonly string _name;
		public MyCustomActionFilterAttribute(string name){
			_name = name;
		}

		public void OnActionExecuting(ActionExecutingContext context){
			Console.WriteLine($"On Action Executing - {_name}");
		}
	
		public void OnActionExecuted(ActionExecutedContext context){
			Console.WriteLine($"On Action Executed - {_name}");
		}
	
	}

 Step 2 : No need to add integration to sevices.AddControllers

 Step 3 : Find the specific controller

 [MyCustomActionFilter("Hello World")]
 public class MyTestController : ControllerBase
 {
 
 }

 This will run only at this controller level

 We can also use at method level
 public class MyTestController : ControllerBase
 {
	
	[HttpGet("Test"")]
	[MyCustomActionFilter("MyMethod")]
	public void Test(){
	}
 }

 -------------------------CUSTOM FILTER ASYNC

 Step 1 : Create an Async Filter
  
  public class MyCustomAsyncFilterAttribute : Attribute, IAsyncActionFilter
  {

		private readonly string _name;
		public MyCustomAsyncFilterAttribute(string name){
			_name = name;
		}

		//This will be just like the custom middleware
		public async Task OnActionExecutingAsync(ActionExecutingContext context, ActionExecutionDelegate next){

			Console.WriteLine($"Before aync execution - {_name}");
			await next();	//Calls next filter
			Console.WriteLine($"After aync execution - {_name}");
		}
  
  }

  Step 2 : 

 public class MyTestController : ControllerBase
 {
	
	[HttpGet("Test"")]
	[MyCustomAsyncFilter("MyMethod")]
	public void Test(){
	}
 }



-----------------------------------------------------------------------------------------------------------------------

[Authorize filters]


-----------------------------------------------------------------------------------------------------------------------

Custom Filters

Attributes

-----------------------------------------------------------------------------------------------------------------------

Middleware vs Filters -

FLow - 
HttpRequest -> Middleware -> Filters -> ActionMethod -> Filter -> Middleware -> HttpResponse

Filters vs Middleware in ASP.NET Core

In .NET Core, both filters and middleware can be used to add additional functionality to an HTTP request pipeline. 
However, there are some differences between the two:

1. Filters are used to add functionality that is specific to an action method or controller, whereas middleware is 
used to add functionality that is applied to all requests passing through the pipeline.

2. Filters are executed in a specific order, based on their type (authorization filters, action filters, result filters, etc.),
whereas middleware is executed in the order it is added to the pipeline.

3. Filters can access and modify the action context and arguments, whereas middleware can only modify the HTTP context.

4. Multiple filters can be applied to a single action method, whereas only one middleware can be applied to a single request.

5. There are many built-in filters in .NET Core, such as authorization filters, action filters, exception filters, 
and resource filters, but middleware is more flexible and allows developers to create their own custom middleware.


-----------------------------------------------------------------------------------------------------------------------

What is .net MAUI?

.NET MAUI (Multi-platform App UI) is a cross-platform UI framework for building native apps using .NET and C#. 
It is the evolution of Xamarin.Forms, a popular UI toolkit for building mobile apps that run on multiple platforms. 
With .NET MAUI, developers can create a single codebase that targets multiple platforms, including iOS, Android, macOS, 
Windows, and Linux.

-----------------------------------------------------------------------------------------------------------------------

What is RateLimiting ?






************************************************************************************************************************
************************************************************************************************************************
If we want to skip certain middlewares how can we do that?

	In custom middleware we can use it via routes.
	1. We can check request path by checking httpContext.Request.Path.Value.Contains()
	2. We can use app.Map()

Q. Middleware flow - Configure vs Configure Services
Q. Custom Exceptions
Q. Custom Validations
Q. Does middleware be called before the controller?. - Yes
Q. DI Containers
Q. CORS - Whitelisting of Websites 



